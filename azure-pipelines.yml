trigger:
  branches:
    include:
      - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  # these two come from your publish-profile and must live in a secret variable group
- group: zipdeploy-secrets  
  # path to the ZIP weâ€™ll create
- name: zipPath
  value: '$(Build.ArtifactStagingDirectory)/app.zip'
  # your full Kudu/SCM URL from the publish profile, without â€œhttps://â€ or â€œ/api/zipdeployâ€
- name: scmHost
  value: 'rymec-demo-app-d6h5gmc9crhnc5g7.scm.centralus-01.azurewebsites.net'

steps:
# 1) Build the Spring Boot executable JAR
- task: Gradle@2
  displayName: 'ğŸ”¨ Build Spring Boot fat-jar'
  inputs:
    gradleWrapperFile: 'gradlew'
    tasks: 'clean bootJar'        # bootJar generates your 50 MB app.jar
    options: '--no-daemon'

# 2) Copy the one and only fat-jar into staging
- task: CopyFiles@2
  displayName: 'ğŸ“¦ Copy app.jar â†’ staging'
  inputs:
    contents: '**/build/libs/app.jar'
    targetFolder: '$(Build.ArtifactStagingDirectory)'
    flattenFolders: true

# 3) Zip it (must contain app.jar at the root of the ZIP)
- task: ArchiveFiles@2
  displayName: 'ğŸ“ Archive app.jar â†’ app.zip'
  inputs:
    rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/app.jar'
    includeRootFolder: false
    archiveType: 'zip'
    archiveFile: '$(zipPath)'
    replaceExistingArchive: true

# 4) Curl the ZIP up to the *exact* Kudu endpoint from your publish profile
- task: Bash@3
  displayName: 'ğŸš€ Deploy via ZipDeploy'
  inputs:
    targetType: 'inline'
    script: |
      echo "Deploying to https://$(scmHost)/api/zipdeploy"
      # build a Base64 â€œuser:passâ€ string so the leading â€˜$â€™ is preserved
      AUTH=$(printf '%s:%s' "$DEPLOY_USER" "$DEPLOY_PASSWORD" | base64)
      curl -v -X POST \
        -H "Authorization: Basic $AUTH" \
        --data-binary "@$(zipPath)" \
        "https://$(scmHost)/api/zipdeploy"
